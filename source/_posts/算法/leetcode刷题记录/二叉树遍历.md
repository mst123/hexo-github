---
title: 二叉树遍历
categories: 
  - 算法
  - 刷题记录
tags: 
  - 算法
  - 二叉树
---

## 常规遍历

[优秀题解](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/tu-jie-er-cha-shu-de-si-chong-bian-li-by-z1m/)

### 递归

递归的代码很简单

#### 前序 中左右

**这种写法其实不好，容易让人误解，return res 会被执行好多次**

```
var preorderTraversal = function(root, res = []) {
  if(!root){
    return res
  }
  res.push(root.val)
  preorderTraversal(root.left, res)
  preorderTraversal(root.right, res)
  return res
};
```

下面这种容易理解

```
var preorderTraversal = function(root) {
	var res = []
  if(!root){
    return res
  }
  res.push(root.val)
  preorderTraversal(root.left, res)
  preorderTraversal(root.right, res)
  return res
};
function handle(root) {

}
```



#### 中序 左中右

```
var preorderTraversal = function(root, res = []) {
  if(!root){
    return res
  }
  preorderTraversal(root.left, res)
  res.push(root.val)
  preorderTraversal(root.right, res)
  return res
};
```

#### 后序 左右中

```
var preorderTraversal = function(root, res = []) {
  if(!root){
    return res
  }
  preorderTraversal(root.left, res)
  preorderTraversal(root.right, res)
  res.push(root.val)
  return res
};
```



### 迭代

迭代的很不容易理解

#### 前序 中左右

普通写法

```
var preorderTraversal = function(root) {
  if(!root){
    return []
  }
  const stack = [];
  const res = []
  stack.push(root)
  while(stack.length){
    const popNode = stack.pop()
    res.push(popNode.val)
    if(popNode.right){
      stack.push(popNode.right)
    }
    if(popNode.left){
      stack.push(popNode.left)
    }
  }
  return res
};
```

**统一写法 前序和中序 结果采集的地方不同，一个是出栈 一个是入栈**

```
var preorderTraversal = function(root) {
  const res = []
  let cur = root
  const stack = []
  while (stack.length || cur) {
    while (cur) {
      res.push(cur.val)
      stack.push(cur)
      cur = cur.left
    }
    const popNode = stack.pop()
    if(popNode.right){
      cur = popNode.right
    }
  }
  return res
};
```

#### 中序 左中右

统一写法

```
var inorderTraversal = (root) => {
  const res = []
  let cur = root
  const stack = []
  while (stack.length || cur) {
    // 找到最左侧的节点，并把沿路的节点全部推入栈中
    while(cur){
      stack.push(cur)
      cur = cur.left
    }
    // 取出栈顶元素
    const popNode = stack.pop()
    // 记录出栈元素
    res.push(popNode.val)
    // 存在右节点 即为父节点 而且左节点已经处理过了
    if(popNode.right){
      cur = popNode.right
    }
  }
  return res
};
```



#### 后序 左右中

可以把前序的普通写法改一下，变成中右左，然后倒着输出

普通写法倒着输出

```
const postorderTraversal = function(root) {
  const res = []
  if(!root){
    return res
  }
  const stack = []
  stack.push(root)
  while(stack.length){
    const popRoot = stack.pop()
    res.push(popRoot.val)
    // 左右换一下顺序
    if(popRoot.left){
      stack.push(popRoot.left)
    }
    if(popRoot.right){
      stack.push(popRoot.right)
    }
  }
  // 倒着输出
  return res.reverse()
};
```

统一写法倒着输出

```
const postorderTraversal = function(root) {
  const res = []
  let cur = root
  const stack = []
  while (stack.length || cur) {
    while (cur) {
      res.push(cur.val)
      stack.push(cur)
      cur = cur.right
    }
    const popNode = stack.pop()
    if(popNode.left){
      cur = popNode.left
    }
  }
  // 把上边的push 换成unshift 这边就不用倒着了 但是时间复杂度更高了，不好
  return res.reverse()
};
```

利用标识符进行迭代,普通写法

```
const postorderTraversal = function(root) {
  if (!root) {
    return []
  }
  const stack = []
  const res = []
  stack.push({
    node: root,
    flag: 0
  })
  while (stack.length) {
    const {node, flag} = stack.pop()
    if (!node) {
      continue
    }
    if (flag === 1) {
      res.push(node.val)
    } else {
      stack.push({
        node: node,
        flag: 1
      })
      stack.push({
        node: node.right,
        flag: 0
      })
      stack.push({
        node: node.left,
        flag: 0
      })
    }
  }
  return res
};
```

### 优秀统一迭代法 直接记这个就好

#### 前序遍历统一迭代法

// 前序遍历：中左右
// 压栈顺序：右左中

```
var preorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        if (node.right) stack.push(node.right); // 右
        if (node.left) stack.push(node.left); // 左
        stack.push(node); // 中
        stack.push(null);
    };
    return res;
};
```

#### 中序遍历统一迭代法



//  中序遍历：左中右
//  压栈顺序：右中左

```
var inorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        if (node.right) stack.push(node.right); // 右
        stack.push(node); // 中
        stack.push(null);
        if (node.left) stack.push(node.left); // 左
    };
    return res;
};
```

#### 后序遍历统一迭代法

// 后续遍历：左右中
// 压栈顺序：中右左

```
var postorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        stack.push(node); // 中
        stack.push(null);
        if (node.right) stack.push(node.right); // 右
        if (node.left) stack.push(node.left); // 左
    };
    return res;
};
```



> 作者：carlsun-2
> 链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/dai-ma-sui-xiang-lu-chi-tou-qian-zhong-hou-xu-de-d/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 层序遍历

leetcode一道基础的题

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

难度中等1081收藏分享切换为英文接收动态反馈

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**示例：**
二叉树：`[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层序遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

### 递归解法

利用层级和数组解决

```
var levelOrder = function(root) {
  const levelArr = []
  handle(root,0,levelArr)
  return levelArr
};
function handle(root, level, levelArr){
  if(!root){
    return
  }
  Array.isArray(levelArr[level]) ? levelArr[level].push(root.val) : levelArr[level] = [root.val]
  level++
  handle(root.left, level, levelArr)
  handle(root.right, level, levelArr)
}
```



